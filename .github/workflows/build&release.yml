name: Build and Release Workflow
on:
  push:
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ master ]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  packages: read

jobs:
  build:
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Go and dependencies
        uses: ./.github/actions/setup-env
        with:
          bust_lumera_retag: 'true'
        
      - name: Build binaries
        run: |
          # Ensure module metadata is up to date
          go mod tidy
          # Build supernode
          CGO_ENABLED=1 go build -trimpath -o /tmp/supernode ./supernode
          
          # Build sn-manager  
          cd sn-manager
          # Ensure sn-manager module metadata is up to date
          go mod tidy
          CGO_ENABLED=0 go build -trimpath -o /tmp/sn-manager .
          
          echo "âœ… Build successful"

  release:
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-22.04
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get tag information
        id: tag_info
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          
          TAG_MESSAGE=$(git tag -l --format='%(contents)' $TAG_NAME)
          if [ -z "$TAG_MESSAGE" ]; then
            TAG_MESSAGE="Release $TAG_NAME"
          fi
          {
            echo "tag_message<<GHOEOF"
            echo "$TAG_MESSAGE"
            echo "GHOEOF"
          } >> "$GITHUB_OUTPUT"

      - name: Setup Go and dependencies
        uses: ./.github/actions/setup-env
        with:
          bust_lumera_retag: 'true'

      - name: Prepare Release Variables
        id: vars
        run: |
          VERSION=${{ steps.tag_info.outputs.tag_name }}
          GIT_COMMIT=$(git rev-parse --short HEAD)
          BUILD_TIME=$(date -u '+%Y-%m-%d_%H:%M:%S')
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "git_commit=$GIT_COMMIT" >> $GITHUB_OUTPUT
          echo "build_time=$BUILD_TIME" >> $GITHUB_OUTPUT
          echo "binary_name=supernode-linux-amd64" >> $GITHUB_OUTPUT

      - name: Build Release Version
        env:
          DD_API_KEY: ${{ secrets.DD_API_KEY }}
          DD_SITE: ${{ secrets.DD_SITE }}
        run: |
          # Ensure module metadata is up to date
          go mod tidy
          mkdir -p release
          
          # Build supernode
          CGO_ENABLED=1 \
          GOOS=linux \
          GOARCH=amd64 \
          go build \
          -trimpath \
          -ldflags="-s -w \
                    -X github.com/LumeraProtocol/supernode/v2/supernode/cmd.Version=${{ steps.vars.outputs.version }} \
                    -X github.com/LumeraProtocol/supernode/v2/supernode/cmd.GitCommit=${{ steps.vars.outputs.git_commit }} \
                    -X github.com/LumeraProtocol/supernode/v2/supernode/cmd.BuildTime=${{ steps.vars.outputs.build_time }} \
                    -X github.com/LumeraProtocol/supernode/v2/supernode/cmd.MinVer=${{ vars.MIN_VER }} \
                    -X github.com/LumeraProtocol/supernode/v2/pkg/logtrace.DDAPIKey=${DD_API_KEY} \
                    -X github.com/LumeraProtocol/supernode/v2/pkg/logtrace.DDSite=${DD_SITE}" \
          -o release/supernode \
          ./supernode
          
          # Build sn-manager
          cd sn-manager
          # Ensure sn-manager module metadata is up to date
          go mod tidy
          CGO_ENABLED=0 \
          GOOS=linux \
          GOARCH=amd64 \
          go build \
          -trimpath \
          -ldflags="-s -w \
                    -X main.Version=${{ steps.vars.outputs.version }} \
                    -X main.GitCommit=${{ steps.vars.outputs.git_commit }} \
                    -X main.BuildTime=${{ steps.vars.outputs.build_time }}" \
          -o ../release/sn-manager \
          .
          cd ..
          
          chmod +x release/supernode release/sn-manager
          
          # Create tarball
          cd release
          tar -czf ${{ steps.vars.outputs.binary_name }}.tar.gz supernode sn-manager
          cd ..
          
          cp release/supernode release/${{ steps.vars.outputs.binary_name }}

      - name: Check if release already exists
        id: rel_check
        uses: actions/github-script@v7
        env:
          TAG_NAME: ${{ steps.tag_info.outputs.tag_name }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag_name = process.env.TAG_NAME;
            try {
              await github.request('GET /repos/{owner}/{repo}/releases/tags/{tag}', {
                owner,
                repo,
                tag: tag_name,
              });
              core.setOutput('exists', 'true');
            } catch (e) {
              // 404 means not found => will be created
              core.setOutput('exists', 'false');
            }

      - name: Generate auto release notes
        id: auto_notes
        uses: actions/github-script@v7
        if: steps.rel_check.outputs.exists != 'true'
        env:
          TAG_NAME: ${{ steps.tag_info.outputs.tag_name }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag_name = process.env.TAG_NAME;
            const res = await github.request('POST /repos/{owner}/{repo}/releases/generate-notes', {
              owner,
              repo,
              tag_name
            });
            core.setOutput('body', res.data.body || '');

      - name: Prepare Release Body
        id: rel_body
        if: steps.rel_check.outputs.exists != 'true'
        run: |
          cat > /tmp/REL_BODY <<'EOT'
          IMPORTANT: sn-manager setup and auto-update guide:
          https://github.com/LumeraProtocol/supernode/blob/master/sn-manager/README.md

          ${{ steps.tag_info.outputs.tag_message }}

          ---
          Auto-generated release notes:
          ${{ steps.auto_notes.outputs.body }}
          EOT
          {
            echo "body<<GHOEOF"
            cat /tmp/REL_BODY
            echo "GHOEOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create release with composed body (no existing release)
        uses: softprops/action-gh-release@v0.1.15
        if: success() && steps.rel_check.outputs.exists != 'true'
        with:
          tag_name: ${{ steps.tag_info.outputs.tag_name }}
          files: |
            release/${{ steps.vars.outputs.binary_name }}.tar.gz
            release/${{ steps.vars.outputs.binary_name }}
          body: ${{ steps.rel_body.outputs.body }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload assets to existing release (preserve manual notes)
        uses: softprops/action-gh-release@v0.1.15
        if: success() && steps.rel_check.outputs.exists == 'true'
        with:
          tag_name: ${{ steps.tag_info.outputs.tag_name }}
          files: |
            release/${{ steps.vars.outputs.binary_name }}.tar.gz
            release/${{ steps.vars.outputs.binary_name }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Ensure guide link present in existing release body
        if: success() && steps.rel_check.outputs.exists == 'true'
        uses: actions/github-script@v7
        env:
          TAG_NAME: ${{ steps.tag_info.outputs.tag_name }}
          GUIDE_URL: https://github.com/LumeraProtocol/supernode/blob/master/sn-manager/README.md
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag_name = process.env.TAG_NAME;
            const guide = `IMPORTANT: sn-manager setup and auto-update guide:\n${process.env.GUIDE_URL}`;
            // Fetch release
            const rel = await github.request('GET /repos/{owner}/{repo}/releases/tags/{tag}', {
              owner,
              repo,
              tag: tag_name,
            });
            const release = rel.data;
            const body = release.body || '';
            if (body.includes(process.env.GUIDE_URL)) {
              core.info('Guide link already present; not modifying release body.');
            } else {
              const newBody = `${guide}\n\n${body}`;
              await github.request('PATCH /repos/{owner}/{repo}/releases/{release_id}', {
                owner,
                repo,
                release_id: release.id,
                body: newBody,
              });
              core.info('Prepended guide link to existing release body.');
            }
